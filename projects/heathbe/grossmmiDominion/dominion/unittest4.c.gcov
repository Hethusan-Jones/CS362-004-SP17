        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:4
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include <assert.h>
        -:    3:#include <time.h>
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:#include <stdlib.h>
        -:    7:#include "interface.h"
        -:    8:#include <math.h>
        -:    9:
        -:   10:#define NUM_TESTS 100
        -:   11:
        -:   12:int testPlayCard(int numPlayers, int *numTests);
        -:   13:
        -:   14:// Need to:
        -:   15:// 		For Coverage purposes engineer following situations and ensure -1 is returned
        -:   16:	// 		- make sure one card effect returns -1, and check for it
        -:   17:	// 		- rig up a condition where the phase isn't 0
        -:   18:	// 		- ensure card is in the playable set, and try to play a card that is not 
        -:   19:	// 		- try to play a card with numActions < 1
        -:   20:	//
        -:   21:	// 	After playing card, the gameState's number of actions should go down
        -:   22:	// 	The number of coins should be updated
        -:   23:
function testPlayCardWrapper called 4 returned 100% blocks executed 100%
        4:   24:int testPlayCardWrapper() {
        4:   25:	int numTests = 0;
        -:   26:	int i, j;
        4:   27:	int totalTestsPassed = 0,
        4:   28:		testsPassed=0;
        4:   29:	printf("\n-------- UNIT TEST 4 ---------\n");
call    0 returned 100%
        -:   30:
       16:   31:	for (i=2; i <= MAX_PLAYERS; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       12:   32:		testsPassed = testPlayCard(i, &numTests);
call    0 returned 100%
       12:   33:		totalTestsPassed += testsPassed;
        -:   34:		
        -:   35:		//printf("Test fails with %d players.\n", i);
        -:   36:		
        -:   37:	}
        -:   38:
        4:   39:	printf("\n%d out of %d tests passed.\n", totalTestsPassed, numTests);
call    0 returned 100%
        -:   40:
        4:   41:	return 0;
        -:   42:}
        -:   43:
function testPlayCard called 12 returned 100% blocks executed 83%
       12:   44:int testPlayCard(int numPlayers, int *numTests) {
       12:   45:	int cards[10] = {adventurer, council_room, feast, gardens, mine,
        -:   46:	       outpost, smithy, village, baron, great_hall};
        -:   47:	int i, j,
        -:   48:	   gardenPos;	
        -:   49:	int gardenTest;
        -:   50:	int equal;
        -:   51:	int testNumber;
       12:   52:	int successes = 0, failures = 0;
        -:   53:	int currentPlayer, nextPlayer;
        -:   54:	int card;
        -:   55:	int stateComp;
       12:   56:	int traceNo = 0;
       12:   57:	char failStr[] = "FAILURE";
        -:   58:
       12:   59:	struct gameState* testGame = newGame();
call    0 returned 100%
       12:   60:	struct gameState* postGame = newGame();
call    0 returned 100%
       12:   61:	memset(testGame, 0, sizeof(struct gameState));
        -:   62:
       12:   63:	initializeGame(numPlayers, cards, 1, testGame);
call    0 returned 100%
        -:   64:	
       12:   65:	printf("\n%d PLAYER TESTS:\n", numPlayers);
call    0 returned 100%
        -:   66:	// Insert Gardens into deck of both players, replacing some card and updating supply piles
       48:   67:	for (i=0; i< numPlayers; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       36:   68:		card = testGame->deck[i][5];
       36:   69:		testGame->deck[i][5] = gardens;
       36:   70:		testGame->supplyCount[gardens]--;
       36:   71:		testGame->supplyCount[card]++;
       36:   72:		card = testGame->deck[i][4];
       36:   73:		testGame->deck[i][4] = village;
       36:   74:		testGame->supplyCount[village]--;
       36:   75:		testGame->supplyCount[card]++;
        -:   76:	}	
        -:   77:
        -:   78:	
        -:   79:	// Find gardens in players' hand
       12:   80:	card = 0;
       48:   81:	while(card != gardens) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      144:   82:		for (i=0; i < 5; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      120:   83:			if (testGame->hand[testGame->whoseTurn][i] == gardens) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
       12:   84:				card = gardens;
       12:   85:				gardenPos = i;
        -:   86:			}
        -:   87:		}
       24:   88:		if (card != gardens)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       12:   89:			endTurn(testGame);
call    0 returned 100%
        -:   90:	}
        -:   91:
       12:   92:	memcpy(postGame, testGame, sizeof(struct gameState));
        -:   93:
       12:   94:	gardenTest = playCard(gardenPos, -1, -1, -1, testGame);
call    0 returned 100%
        -:   95:	
        -:   96:	// Check for proper return code 
       12:   97:	printf("Testing that playing a non-playable kingdom card does not work...\n");
call    0 returned 100%
       12:   98:	if (gardenTest != -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   99:		printf("%s: Gardens does not return proper number from playCard\n", failStr);
call    0 never executed
    #####:  100:		failures++;
        -:  101:	}
       12:  102:	else successes++;
        -:  103:	
        -:  104:	// Now check for no other state changes
       12:  105:	printf("Testing gamestate integrity for this call...\n");
call    0 returned 100%
       12:  106:	stateComp = memcmp(postGame, testGame, sizeof(struct gameState));
       12:  107:	if (stateComp != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  108:		printf("%s: State changed when it wasn't supposed to.\n", failStr);
call    0 never executed
    #####:  109:		failures++;
        -:  110:	}
       12:  111:	else successes++;
        -:  112:	
        -:  113:	
        -:  114:
       12:  115:	card = 0;
        -:  116:	int cardPos;
        -:  117:	// Manually edit phase to != 0 and search for playable card
       12:  118:	testGame->phase = 1;
       36:  119:	while (card < adventurer || card > treasure_map) {
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
       72:  120:		for (i=0; i < 5; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
       60:  121:			card = testGame->hand[testGame->whoseTurn][i];
       60:  122:			if ((card >= adventurer) && card < treasure_map && card != gardens) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  123:				cardPos = i;
        -:  124:				}
        -:  125:		}
       12:  126:		if (card < adventurer || card > treasure_map)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  127:			endTurn(testGame);
call    0 never executed
        -:  128:	}
        -:  129:
        -:  130:	int phaseTest;
       12:  131:	memcpy(postGame, testGame, sizeof(struct gameState));
       12:  132:	phaseTest = playCard(cardPos, -1, -1, -1, testGame);
call    0 returned 100%
        -:  133:	
       12:  134:	printf("Testing that playing a card in wrong phase does not work...\n");
call    0 returned 100%
       12:  135:	if (phaseTest != -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  136:		printf("%s: Phase not properly accounted for in playCard()\n", failStr);
call    0 never executed
    #####:  137:		failures++;
        -:  138:	}
       12:  139:	else successes++;
        -:  140:	// Now check for no other state changes
       12:  141:	printf("Testing gamestate integrity for this call...\n");
call    0 returned 100%
       12:  142:	stateComp = memcmp(postGame, testGame, sizeof(struct gameState));
       12:  143:	if (stateComp != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  144:		printf("%s: State changed when it wasn't supposed to.\n", failStr);
call    0 never executed
    #####:  145:		failures++;
        -:  146:	}
       12:  147:	else successes++;
        -:  148:	
        -:  149:
        -:  150:
       12:  151:	testGame->phase = 0;
        -:  152:	// Now try to play a card not in playable set (money or victory card)
       12:  153:	card = adventurer;
       12:  154:	cardPos = 0;
        -:  155:	// Manually edit phase to != 0
       60:  156:	while(card >= adventurer) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      216:  157:		for (i=0; i < 5; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      180:  158:			card = testGame->hand[testGame->whoseTurn][i];
      180:  159:			if (card < adventurer) 
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
      144:  160:				cardPos = i;
        -:  161:		}
       36:  162:		if (card > adventurer)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       24:  163:			endTurn(testGame);
call    0 returned 100%
        -:  164:	}
        -:  165:	// Now test playing unplayable card
       12:  166:	memcpy(postGame, testGame, sizeof(struct gameState));
       12:  167:	int noPlayCardTest = playCard(cardPos, -1, -1, -1, testGame);
call    0 returned 100%
       12:  168:	printf("Testing that playing a card not in playable set does not work...\n");
call    0 returned 100%
       12:  169:	if (noPlayCardTest != -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  170:		printf("%s: Playing unplayable card does not return proper number.\n", failStr);
call    0 never executed
    #####:  171:		failures++;
        -:  172:	}
       12:  173:	else successes++;
        -:  174:	
        -:  175:	// Now check for no other state changes
       12:  176:	stateComp = memcmp(postGame, testGame, sizeof(struct gameState));
       12:  177:	printf("Testing gamestate integrity for this call...\n");
call    0 returned 100%
       12:  178:	if (stateComp != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  179:		printf("%s: State changed when it wasn't supposed to.\n", failStr);
call    0 never executed
    #####:  180:		failures++;
        -:  181:	}
       12:  182:	else successes++;
        -:  183:	
        -:  184:
        -:  185:	// Finally, test playCard failure for attempting to play with no actions available
       12:  186:	card = 0;
       12:  187:	cardPos = 0;
        -:  188:	// Manually edit phase to != 0 and search for playable card
      144:  189:	while (card < adventurer || card > treasure_map || card == gardens) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 25%
branch  5 taken 75% (fallthrough)
      720:  190:		for (i=0; i < 5; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      600:  191:			card = testGame->hand[testGame->whoseTurn][i];
      600:  192:			if ((card >= adventurer) && card < treasure_map && card != gardens) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 74% (fallthrough)
branch  5 taken 26%
       80:  193:				cardPos = i;
        -:  194:				}
        -:  195:		}
      120:  196:		if (card < adventurer || card > treasure_map || card == gardens)
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 25% (fallthrough)
branch  5 taken 75%
      108:  197:			endTurn(testGame);
call    0 returned 100%
        -:  198:	}
        -:  199:
       12:  200:	testGame->numActions = 0;
       12:  201:	memcpy(postGame, testGame, sizeof(struct gameState));
       12:  202:	int numActionPlayTest = playCard(cardPos, -1, -1, -1, testGame);
call    0 returned 100%
       12:  203:	printf("Testing that playing a card when no actions are available does not work...\n");
call    0 returned 100%
       12:  204:	if (numActionPlayTest != -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  205:		printf("%s: Attempting to play card without an action doesn't fail as it should.\n", failStr);
call    0 never executed
    #####:  206:		failures++;
        -:  207:	}
       12:  208:	else successes++;
        -:  209:	
        -:  210:	// Now check for no other state changes
       12:  211:	stateComp = memcmp(postGame, testGame, sizeof(struct gameState));
       12:  212:	printf("Testing gamestate integrity for this call...\n");
call    0 returned 100%
       12:  213:	if (stateComp != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  214:		printf("State changed for numActions when it wasn't supposed to.\n");
call    0 never executed
    #####:  215:		failures++;
        -:  216:	}
       12:  217:	else successes++;
        -:  218:	
        -:  219:
        -:  220:
       12:  221:	endTurn(testGame);
call    0 returned 100%
        -:  222:
       12:  223:	card = 0;
       44:  224:	 while (card != village) {
branch  0 taken 63%
branch  1 taken 38% (fallthrough)
      120:  225:		for (i=0; i < 5; i++) {
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      100:  226:			if (testGame->hand[testGame->whoseTurn][i] == village) {
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
       12:  227:				card = village;
       12:  228:				cardPos = i;
        -:  229:			}
        -:  230:		}
       20:  231:		if (card != village) {
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        8:  232:			endTurn(testGame);
call    0 returned 100%
        -:  233:		}
        -:  234:	 }
        -:  235:
        -:  236:
        -:  237:	// Ensure no improper state change after successful call to playCard()
       12:  238:	memcpy(postGame, testGame, sizeof(struct gameState));
       12:  239:	int playCardTest = playCard(cardPos, -1, -1, -1, testGame);
call    0 returned 100%
        -:  240:	// BUG Found - when there are 4 players, playCard() can cause an extra coin to be added to player's coins despite not drawing one
        -:  241:	
        -:  242:    //printf("Card drawn in testGame: %d \n", testGame->hand[whoseTurn(testGame)][testGame->handCount[whoseTurn(testGame)]]);
       12:  243:	assert(playCardTest == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  244:	// Manually edit state for postGame
       12:  245:	currentPlayer = whoseTurn(postGame);
call    0 returned 100%
        -:  246:	//+1 Card
       12:  247:	drawCard(currentPlayer, postGame);
call    0 returned 100%
        -:  248:		
       12:  249:	postGame->numActions = postGame->numActions + 1;
        -:  250:	//discard played card from hand
       12:  251:	discardCard(cardPos, currentPlayer, postGame, 0);
call    0 returned 100%
        -:  252:	// Update coins and actions
       12:  253:	postGame->numActions--;
       12:  254:	updateCoins(currentPlayer, postGame, 0);
call    0 returned 100%
        -:  255:
       12:  256:	stateComp = memcmp(postGame, testGame, sizeof(struct gameState));
       12:  257:	printf("Ensuring Gamestate consistency following successful call to playCard()...\n");
call    0 returned 100%
       12:  258:	if (stateComp != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       12:  259:		printf("%s: Improper state change after successful play of card\n", failStr);
call    0 returned 100%
       12:  260:		failures++;
        -:  261:	}
    #####:  262:	else successes++;
        -:  263:
       12:  264:	free(testGame);
       12:  265:	free(postGame);
        -:  266:	
        -:  267:	
       12:  268:	*numTests += successes + failures;
       12:  269:	return successes;
        -:  270:}
        -:  271:
        -:  272:
function main called 4 returned 100% blocks executed 100%
        4:  273:int main() {
        4:  274:	testPlayCardWrapper();
call    0 returned 100%
        -:  275:
        4:  276:	return 0;
        -:  277:}
